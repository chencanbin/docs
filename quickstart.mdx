---
title: 'å¿«é€Ÿå¼€å§‹'
description: '30ç§’å¿«é€Ÿä½“éªŒAPIä¸­è½¬ç«™æœåŠ¡'
---

# å¿«é€Ÿæ¥å…¥

> 30ç§’ä½“éªŒä¼ä¸šçº§AIæœåŠ¡ï¼Œé‡Šæ”¾æ— é™åˆ›é€ åŠ›

<div align="center">
  # å¿«é€Ÿæ¥å…¥

  **ä¸€é”®è¿æ¥30+ä¸»æµAIæœåŠ¡å•†**\
  é›¶ä»£ç è¿ç§» Â· æ™ºèƒ½è·¯ç”± Â· æˆæœ¬ä¼˜åŒ–
</div>

***

## æ ¸å¿ƒç†å¿µ

gptprotoé‡‡ç”¨**å¼‚æ­¥ä»»åŠ¡æ¶æ„**ï¼Œæ‰€æœ‰AIæœåŠ¡ä»¥ä»»åŠ¡å½¢å¼å¤„ç†ï¼š

<CardGroup cols={3}>
  <Card title="æäº¤ä»»åŠ¡" icon="paper-plane">
    å‘é€è¯·æ±‚ï¼Œç«‹å³è¿”å›ä»»åŠ¡ID
  </Card>

  <Card title="å®æ—¶ç›‘æ§" icon="chart-line">
    æŸ¥è¯¢è¿›åº¦ï¼Œè·å–çŠ¶æ€æ›´æ–°
  </Card>

  <Card title="è·å–ç»“æœ" icon="download">
    ä»»åŠ¡å®Œæˆåè·å–æœ€ç»ˆç»“æœ
  </Card>
</CardGroup>

***

## å‡†å¤‡å·¥ä½œ

### è·å–APIå¯†é’¥

<Steps>
  <Step title="æ³¨å†Œè´¦æˆ·">
    è®¿é—® [gptprotoæ§åˆ¶å°](https://admin.gptproto.com) å®Œæˆæ³¨å†Œ
  </Step>

  <Step title="åˆ›å»ºå¯†é’¥">
    è¿›å…¥APIç®¡ç†é¡µé¢ï¼Œç‚¹å‡»"æ–°å»ºå¯†é’¥"
  </Step>

  <Step title="ä¿å­˜å¯†é’¥">
    å¤åˆ¶ç”Ÿæˆçš„APIå¯†é’¥ï¼ˆæ ¼å¼ï¼š`sk-evo-xxxxxxxxxx`ï¼‰
  </Step>
</Steps>

<Warning>
  APIå¯†é’¥å…·æœ‰å®Œæ•´è´¦æˆ·æƒé™ï¼Œè¯·å¦¥å–„ä¿ç®¡ã€‚å¦‚å‘ç°æ³„éœ²ï¼Œç«‹å³é‡ç½®ã€‚
</Warning>

***

## 30ç§’å¿«é€Ÿä½“éªŒ

### å›¾åƒç”Ÿæˆç¤ºä¾‹

```bash
# æäº¤å›¾åƒç”Ÿæˆä»»åŠ¡
curl -X POST https://api.gptproto.ai/v1/images/generations \\
  -H "Authorization: Bearer YOUR_API_KEY" \\
  -H "Content-Type: application/json" \\
  -d '{
    "model": "gpt-4o-image",
    "prompt": "ä¸€åªåœ¨è‰åœ°ä¸Šå¥”è·‘çš„å¯çˆ±çŒ«å’ªï¼Œå¤•é˜³è¥¿ä¸‹ï¼Œæ¸©æš–å…‰çº¿"
  }'
```

**ç«‹å³å“åº” - ä»»åŠ¡å·²åˆ›å»º**

```json
{
  "created": 1757156493,
  "id": "task-unified-1757156493-imcg5zqt",
  "model": "gpt-4o-image",
  "object": "image.generation.task",
  "progress": 0,
  "status": "pending",
  "task_info": {
    "can_cancel": true,
    "estimated_time": 100
  },
  "type": "image",
  "usage": {
    "billing_rule": "per_call",
    "credits_reserved": 252,
    "estimated_cost": 0.252,
    "user_group": "default"
  }
}
```

### æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€

```bash
# ä½¿ç”¨è¿”å›çš„ä»»åŠ¡IDæŸ¥è¯¢çŠ¶æ€
curl https://api.gptproto.ai/v1/tasks/task-unified-1757156493-imcg5zqt \\
  -H "Authorization: Bearer YOUR_API_KEY"
```

**ä»»åŠ¡å®Œæˆåçš„å“åº”**

```json
{
  "created": 1757156493,
  "id": "task-unified-1757156493-imcg5zqt",
  "model": "gpt-4o-image",
  "object": "image.generation.task",
  "progress": 100,
  "results": [
    "https://tempfile.aiquickdraw.com/s/generated_image_url.png"
  ],
  "status": "completed",
  "task_info": {
    "can_cancel": false
  },
  "type": "image"
}
```

***

## å¤šæ¨¡æ€AIèƒ½åŠ›

### ğŸ¨ å›¾åƒç”Ÿæˆ

<Tabs>
  <Tab title="GPT-4O Image">
    ```python
    import requests

    # GPT-4O å›¾åƒç”Ÿæˆ
    response = requests.post(
        "https://api.gptproto.ai/v1/images/generations",
        headers={"Authorization": "Bearer YOUR_API_KEY"},
        json={
            "model": "gpt-4o-image",
            "prompt": "æµ·é¢ä¸Šç»šä¸½å¤šå½©çš„ç¾ä¸½æ—¥è½",
            "size": "1024x1024",
            "n": 1
        }
    )

    task = response.json()
    print(f"ä»»åŠ¡ID: {task['id']}")
    print(f"é¢„ä¼°æ—¶é—´: {task['task_info']['estimated_time']}ç§’")
    ```
  </Tab>

  <Tab title="Seedream 4.0">
    ```python
    # Seedream 4.0 å›¾åƒç”Ÿæˆ
    response = requests.post(
        "https://api.gptproto.ai/v1/images/generations",
        headers={"Authorization": "Bearer YOUR_API_KEY"},
        json={
            "model": "doubao-seedream-4.0",
            "prompt": "æœªæ¥ç§‘æŠ€åŸå¸‚ï¼Œéœ“è™¹ç¯é—ªçƒçš„å¤œæ™¯"
        }
    )

    task = response.json()
    print(f"ä»»åŠ¡åˆ›å»º: {task['created']}")
    print(f"æˆæœ¬é¢„ä¼°: ${task['usage']['estimated_cost']}")
    ```
  </Tab>
</Tabs>

### ğŸ¬ è§†é¢‘ç”Ÿæˆ

```python
import requests
import time

# Veo3-Fast è§†é¢‘ç”Ÿæˆ
def generate_video():
    # æäº¤è§†é¢‘ç”Ÿæˆä»»åŠ¡
    response = requests.post(
        "https://api.gptproto.ai/v1/videos/generations",
        headers={"Authorization": "Bearer YOUR_API_KEY"},
        json={
            "model": "veo3-fast",
            "prompt": "ä¸€åªçŒ«åœ¨èŠ±å›­é‡Œè¿½è´è¶ï¼Œæ…¢é•œå¤´",
            "aspect_ratio": "16:9"
        }
    )
    
    task = response.json()
    task_id = task['id']
    
    print(f"è§†é¢‘ä»»åŠ¡å·²åˆ›å»º: {task_id}")
    print(f"é¢„ä¼°å®Œæˆæ—¶é—´: {task['task_info']['estimated_time']}ç§’")
    print(f"é¢„ä¼°æˆæœ¬: ${task['usage']['estimated_cost']}")
    
    return task_id

# ç›‘æ§ä»»åŠ¡è¿›åº¦
def monitor_task(task_id):
    while True:
        response = requests.get(
            f"https://api.gptproto.ai/v1/tasks/{task_id}",
            headers={"Authorization": "Bearer YOUR_API_KEY"}
        )
        
        task = response.json()
        status = task['status']
        progress = task['progress']
        
        print(f"çŠ¶æ€: {status}, è¿›åº¦: {progress}%")
        
        if status == "completed":
            return task['results'][0]  # è§†é¢‘URLåœ¨resultsæ•°ç»„ä¸­
        elif status == "failed":
            raise Exception(f"ä»»åŠ¡å¤±è´¥: {task.get('error')}")
        
        time.sleep(10)  # æ¯10ç§’æŸ¥è¯¢ä¸€æ¬¡

# ä½¿ç”¨ç¤ºä¾‹
task_id = generate_video()
video_url = monitor_task(task_id)
print(f"è§†é¢‘ç”Ÿæˆå®Œæˆ: {video_url}")
```

***

## SDK å¿«é€Ÿé›†æˆ

### Python SDK

```python
import openai
import requests

class gptprotoClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.gptproto.ai"
        self.headers = {"Authorization": f"Bearer {api_key}"}
    
    def create_image(self, model, prompt, **kwargs):
        """åˆ›å»ºå›¾åƒç”Ÿæˆä»»åŠ¡"""
        response = requests.post(
            f"{self.base_url}/v1/images/generations",
            headers=self.headers,
            json={"model": model, "prompt": prompt, **kwargs}
        )
        return response.json()
    
    def create_video(self, model, prompt, **kwargs):
        """åˆ›å»ºè§†é¢‘ç”Ÿæˆä»»åŠ¡"""
        response = requests.post(
            f"{self.base_url}/v1/videos/generations",
            headers=self.headers,
            json={"model": model, "prompt": prompt, **kwargs}
        )
        return response.json()
    
    def get_task(self, task_id):
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        response = requests.get(
            f"{self.base_url}/v1/tasks/{task_id}",
            headers=self.headers
        )
        return response.json()
    
    def wait_for_completion(self, task_id, timeout=300):
        """ç­‰å¾…ä»»åŠ¡å®Œæˆ"""
        import time
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            task = self.get_task(task_id)
            
            if task['status'] == 'completed':
                return task['result']
            elif task['status'] == 'failed':
                raise Exception(f"ä»»åŠ¡å¤±è´¥: {task.get('error')}")
            
            time.sleep(5)
        
        raise TimeoutError("ä»»åŠ¡æ‰§è¡Œè¶…æ—¶")

# ä½¿ç”¨ç¤ºä¾‹
client = gptprotoClient("YOUR_API_KEY")

# ç”Ÿæˆå›¾åƒ
task = client.create_image(
    model="gpt-4o-image",
    prompt="ä¸€åº§ç°ä»£åŒ–çš„æ™ºèƒ½åŠå…¬å¤§æ¥¼"
)

result = client.wait_for_completion(task['id'])
print(f"å›¾åƒURL: {result['results'][0]}")
```

### JavaScript/Node.js

```javascript
class gptprotoClient {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseURL = 'https://api.gptproto.ai';
  }
  
  async createImage(model, prompt, options = {}) {
    const response = await fetch(`${this.baseURL}/v1/images/generations`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ model, prompt, ...options })
    });
    
    return response.json();
  }
  
  async getTask(taskId) {
    const response = await fetch(`${this.baseURL}/v1/tasks/${taskId}`, {
      headers: { 'Authorization': `Bearer ${this.apiKey}` }
    });
    
    return response.json();
  }
  
  async waitForCompletion(taskId, timeout = 300000) {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const task = await this.getTask(taskId);
      
      if (task.status === 'completed') {
        return task.result;
      } else if (task.status === 'failed') {
        throw new Error(`ä»»åŠ¡å¤±è´¥: ${task.error}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
    
    throw new Error('ä»»åŠ¡æ‰§è¡Œè¶…æ—¶');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function generateImage() {
  const client = new gptprotoClient('YOUR_API_KEY');
  
  try {
    // åˆ›å»ºä»»åŠ¡
    const task = await client.createImage(
      'doubao-seedream-4.0',
      'ä¸€å¹…æŠ½è±¡è‰ºæœ¯ç”»ï¼Œè‰²å½©ä¸°å¯Œ'
    );
    
    console.log('ä»»åŠ¡å·²åˆ›å»º:', task.id);
    
    // ç­‰å¾…å®Œæˆ
    const result = await client.waitForCompletion(task.id);
    console.log('å›¾åƒç”Ÿæˆå®Œæˆ:', result.results[0]);
    
  } catch (error) {
    console.error('ç”Ÿæˆå¤±è´¥:', error.message);
  }
}

generateImage();
```

***

## ç”Ÿäº§ç¯å¢ƒå®è·µ

### é”™è¯¯å¤„ç†ç­–ç•¥

```python
import requests
from typing import Optional
import time

class gptprotoError(Exception):
    """gptproto APIå¼‚å¸¸åŸºç±»"""
    pass

class RateLimitError(gptprotoError):
    """é¢‘ç‡é™åˆ¶å¼‚å¸¸"""
    pass

class QuotaExhaustedError(gptprotoError):
    """é…é¢è€—å°½å¼‚å¸¸"""
    pass

def handle_api_call(func, *args, **kwargs):
    """ç»Ÿä¸€APIè°ƒç”¨é”™è¯¯å¤„ç†"""
    max_retries = 3
    retry_delay = 1
    
    for attempt in range(max_retries):
        try:
            response = func(*args, **kwargs)
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 429:
                # é¢‘ç‡é™åˆ¶ï¼Œç­‰å¾…åé‡è¯•
                wait_time = int(response.headers.get('Retry-After', retry_delay))
                print(f"è§¦å‘é¢‘ç‡é™åˆ¶ï¼Œç­‰å¾…{wait_time}ç§’åé‡è¯•...")
                time.sleep(wait_time)
                retry_delay *= 2
                continue
            elif response.status_code == 402:
                raise QuotaExhaustedError("è´¦æˆ·ä½™é¢ä¸è¶³ï¼Œè¯·å……å€¼")
            else:
                error_data = response.json()
                raise gptprotoError(f"APIè°ƒç”¨å¤±è´¥: {error_data.get('error', {}).get('message')}")
                
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise gptprotoError(f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {str(e)}")
            time.sleep(retry_delay)
            retry_delay *= 2
    
    raise gptprotoError("è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")

# ä½¿ç”¨ç¤ºä¾‹
try:
    result = handle_api_call(
        requests.post,
        "https://api.gptproto.ai/v1/images/generations",
        headers={"Authorization": "Bearer YOUR_API_KEY"},
        json={"model": "gpt-4o-image", "prompt": "æµ‹è¯•å›¾åƒ"}
    )
    print("ä»»åŠ¡åˆ›å»ºæˆåŠŸ:", result['id'])
except QuotaExhaustedError:
    print("è¯·å‰å¾€æ§åˆ¶å°å……å€¼: https://gptproto.ai/dashboard/billing")
except gptprotoError as e:
    print(f"APIè°ƒç”¨å¼‚å¸¸: {e}")
```

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

<Tabs>
  <Tab title="æ‰¹é‡å¤„ç†">
    ```python
    import asyncio
    import aiohttp

    async def create_task_async(session, model, prompt):
        """å¼‚æ­¥åˆ›å»ºä»»åŠ¡"""
        async with session.post(
            "https://api.gptproto.ai/v1/images/generations",
            json={"model": model, "prompt": prompt}
        ) as response:
            return await response.json()

    async def batch_generate_images(prompts, model="gpt-4o-image"):
        """æ‰¹é‡ç”Ÿæˆå›¾åƒ"""
        headers = {"Authorization": "Bearer YOUR_API_KEY"}
        
        async with aiohttp.ClientSession(headers=headers) as session:
            # å¹¶å‘åˆ›å»ºæ‰€æœ‰ä»»åŠ¡
            tasks = [
                create_task_async(session, model, prompt) 
                for prompt in prompts
            ]
            results = await asyncio.gather(*tasks)
            
            # è¿”å›ä»»åŠ¡IDåˆ—è¡¨
            return [result['id'] for result in results]

    # ä½¿ç”¨ç¤ºä¾‹
    prompts = [
        "ç°ä»£åŠå…¬å®¤è®¾è®¡",
        "è‡ªç„¶é£æ™¯ç”»",
        "æŠ½è±¡è‰ºæœ¯ä½œå“",
        "ç§‘æŠ€æ„ŸUIç•Œé¢"
    ]

    task_ids = asyncio.run(batch_generate_images(prompts))
    print(f"å·²åˆ›å»º{len(task_ids)}ä¸ªä»»åŠ¡")
    ```
  </Tab>

  <Tab title="ä»»åŠ¡æ± ç®¡ç†">
    ```python
    from concurrent.futures import ThreadPoolExecutor
    import queue
    import threading

    class TaskManager:
        def __init__(self, api_key, max_workers=5):
            self.api_key = api_key
            self.headers = {"Authorization": f"Bearer {api_key}"}
            self.task_queue = queue.Queue()
            self.result_queue = queue.Queue()
            self.executor = ThreadPoolExecutor(max_workers=max_workers)
            self.running = True
        
        def submit_task(self, model, prompt, **kwargs):
            """æäº¤ä»»åŠ¡åˆ°é˜Ÿåˆ—"""
            task_data = {"model": model, "prompt": prompt, **kwargs}
            future = self.executor.submit(self._process_task, task_data)
            return future
        
        def _process_task(self, task_data):
            """å¤„ç†å•ä¸ªä»»åŠ¡"""
            # åˆ›å»ºä»»åŠ¡
            response = requests.post(
                "https://api.gptproto.ai/v1/images/generations",
                headers=self.headers,
                json=task_data
            )
            task = response.json()
            
            # ç­‰å¾…å®Œæˆ
            return self._wait_for_completion(task['id'])
        
        def _wait_for_completion(self, task_id):
            """ç­‰å¾…ä»»åŠ¡å®Œæˆ"""
            while True:
                response = requests.get(
                    f"https://api.gptproto.ai/v1/tasks/{task_id}",
                    headers=self.headers
                )
                task = response.json()
                
                if task['status'] == 'completed':
                    return task
                elif task['status'] == 'failed':
                    raise Exception(f"ä»»åŠ¡å¤±è´¥: {task.get('error')}")
                
                time.sleep(5)

    # ä½¿ç”¨ç¤ºä¾‹
    manager = TaskManager("YOUR_API_KEY")

    futures = []
    for i in range(10):
        future = manager.submit_task(
            model="gpt-4o-image",
            prompt=f"è®¾è®¡å›¾ {i+1}"
        )
        futures.append(future)

    # è·å–æ‰€æœ‰ç»“æœ
    for i, future in enumerate(futures):
        try:
            result = future.result(timeout=300)
            print(f"ä»»åŠ¡{i+1}å®Œæˆ: {result['results'][0]}")
        except Exception as e:
            print(f"ä»»åŠ¡{i+1}å¤±è´¥: {e}")
    ```
  </Tab>
</Tabs>

***

## ç›‘æ§ä¸åˆ†æ

### ä½¿ç”¨æƒ…å†µç›‘æ§

è®¿é—® [gptprotoæ§åˆ¶å°](https://gptproto.ai/dashboard) å®æ—¶æŸ¥çœ‹ï¼š

<CardGroup cols={2}>
  <Card title="å®æ—¶ç›‘æ§" icon="chart-mixed">
    * APIè°ƒç”¨æ¬¡æ•°ç»Ÿè®¡
    * æˆåŠŸç‡å’Œé”™è¯¯ç‡
    * å“åº”æ—¶é—´åˆ†æ
    * å¹¶å‘è¯·æ±‚ç›‘æ§
  </Card>

  <Card title="æˆæœ¬åˆ†æ" icon="coins">
    * æŒ‰æ¨¡å‹çš„è´¹ç”¨åˆ†å¸ƒ
    * æ—¥/æœˆä½¿ç”¨è¶‹åŠ¿
    * æˆæœ¬é¢„æµ‹å’Œé¢„è­¦
    * é…é¢ä½¿ç”¨æƒ…å†µ
  </Card>
</CardGroup>

### è‡ªå®šä¹‰ç›‘æ§

```python
import logging
from datetime import datetime

class gptprotoMonitor:
    def __init__(self):
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('gptproto_api.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def log_task_creation(self, task_id, model, cost):
        """è®°å½•ä»»åŠ¡åˆ›å»º"""
        self.logger.info(f"ä»»åŠ¡åˆ›å»º | ID:{task_id} | æ¨¡å‹:{model} | æˆæœ¬:${cost}")
        
    def log_task_completion(self, task_id, duration, status):
        """è®°å½•ä»»åŠ¡å®Œæˆ"""
        self.logger.info(f"ä»»åŠ¡å®Œæˆ | ID:{task_id} | è€—æ—¶:{duration}s | çŠ¶æ€:{status}")
        
    def log_error(self, error, context=""):
        """è®°å½•é”™è¯¯"""
        self.logger.error(f"APIé”™è¯¯ | {context} | {str(error)}")

# ä½¿ç”¨ç¤ºä¾‹
monitor = gptprotoMonitor()

# åœ¨APIè°ƒç”¨ä¸­ä½¿ç”¨
start_time = time.time()
try:
    task = client.create_image("gpt-4o-image", "æµ‹è¯•æç¤º")
    monitor.log_task_creation(
        task['id'], 
        task['model'], 
        task['usage']['estimated_cost']
    )
    
    result = client.wait_for_completion(task['id'])
    duration = time.time() - start_time
    monitor.log_task_completion(task['id'], int(duration), "completed")
    
except Exception as e:
    monitor.log_error(e, f"ä»»åŠ¡ID: {task.get('id', 'unknown')}")
```

***

## æœ€ä½³å®è·µæ€»ç»“

<CardGroup cols={2}>
  <Card title="å¼€å‘å»ºè®®" icon="code">
    * å§‹ç»ˆè¿›è¡Œé”™è¯¯å¤„ç†
    * ä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹æé«˜æ•ˆç‡
    * åˆç†è®¾ç½®è¶…æ—¶æ—¶é—´
    * è®°å½•è¯¦ç»†çš„è°ƒç”¨æ—¥å¿—
  </Card>

  <Card title="æ€§èƒ½ä¼˜åŒ–" icon="rocket">
    * æ‰¹é‡å¤„ç†å‡å°‘ç½‘ç»œå¼€é”€
    * ä½¿ç”¨ä»»åŠ¡æ± ç®¡ç†å¹¶å‘
    * ç›‘æ§APIé…é¢ä½¿ç”¨æƒ…å†µ
    * ç¼“å­˜å¸¸ç”¨çš„ç”Ÿæˆç»“æœ
  </Card>

  <Card title="å®‰å…¨è€ƒè™‘" icon="shield">
    * APIå¯†é’¥å®‰å…¨å­˜å‚¨
    * ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®
    * å®šæœŸè½®æ¢è®¿é—®å¯†é’¥
    * ç›‘æ§å¼‚å¸¸è°ƒç”¨è¡Œä¸º
  </Card>

  <Card title="æˆæœ¬æ§åˆ¶" icon="chart-pie">
    * è®¾ç½®åˆç†çš„é¢„ç®—é™åˆ¶
    * é€‰æ‹©é€‚åˆçš„æ¨¡å‹
    * ä¼˜åŒ–æç¤ºè¯é•¿åº¦
    * ç›‘æ§ä½¿ç”¨é‡è¶‹åŠ¿
  </Card>
</CardGroup>

***

<div align="center">
  ## å‡†å¤‡å°±ç»ªï¼Ÿ

  **ç«‹å³å¼€å§‹æ‚¨çš„AIåˆ›é€ ä¹‹æ—…**

  <CardGroup cols={3}>
    <Card title="æ§åˆ¶å°" icon="browser" href="https://gptproto.ai/dashboard">
      ç®¡ç†APIå¯†é’¥å’Œç›‘æ§ä½¿ç”¨æƒ…å†µ
    </Card>

    <Card title="APIæ–‡æ¡£" icon="book" href="https://docs.gptproto.ai/cn/api-manual/image-series/gpt-4o-image-generation">
      æŸ¥çœ‹è¯¦ç»†çš„æ¥å£æ–‡æ¡£
    </Card>

    <Card title="ä»»åŠ¡ç®¡ç†" icon="list-check" href="https://gptproto.ai/dashboard/usage">
      äº†è§£ä»»åŠ¡çŠ¶æ€æŸ¥è¯¢
    </Card>
  </CardGroup>

  **éœ€è¦å¸®åŠ©ï¼Ÿ** æˆ‘ä»¬çš„æŠ€æœ¯å›¢é˜Ÿéšæ—¶ä¸ºæ‚¨æä¾›ä¸“ä¸šæ”¯æŒ
</div>
